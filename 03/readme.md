# «Поведенческие шаблоны: Command, Iterator, Observer, Chain of Responsibility»


### Цель задания

Выполнив это задание, вы закрепите знания и понимание идеи паттернов:

- команда,
- наблюдатель,
- цепочка ответственности.

Цель домашней работы — продемонстрировать способ реализации одной и той же задачи логирования
по-разному в зависимости от применяемого паттерна проектирования.

------



### Задание 1. Паттерн «Команда»

Пишем команды для системы логирования.

В задании нужно реализовать наследников класса:
```
class LogCommand {
public:
    virtual ~LogCommand() = default;
    virtual void print(const std::string& message) = 0;
};
```

таким образом, чтобы один наследник печатал сообщение message в консоль, а другой умел печатать сообщение в файл, по указанному пути.

Далее нужно реализовать функцию: `oid print(LogCommand&);`, которая будет
выполнять команды.


------

### Задание 2. Паттерн «Наблюдатель»

Развиваем идею с логированием и пишем класс, за которым смогут наблюдать различные наблюдатели и реагировать на те или иные события.

В задании нужно реализовать несколько классов:

1. Наблюдаемый класс с методами:
- `void warning(const std::string& message) const;`
- `void error(const std::string& message) const;`
- `void fatalError(const std::string& message) const;`

Этот объект должен:

- уметь добавлять не владеющие указатели на наблюдателей,
- оповещать наблюдателей о вызове каждого из методов,
- корректно обрабатывать разрушение объектов-наблюдателей.

2. Далее нужно реализовать небольшую иерархию классов-наблюдателей, реализующих интерфейс:
```
class Observer {
public:
    virtual void onWarning(const std::string& message) {}
    virtual void onError(const std::string& message) {}
    virtual void onFatalError(const std::string& message) {}
};
```

В иерархии классов-наблюдателей нужно реализовать:

- класс для работы с предупреждениями, который будет печатать сообщение в консоль;
- класс для работы с ошибками, который будет печатать сообщение в файл по указанному пути;
- класс для работы с фатальными ошибками, который будет печатать сообщение в консоль и в файл по указанному пути.

------

### Задание 3. Паттерн «Цепочка ответственности»

Продолжаем тему с реализацией системы логирования в соответствии с разными паттернами проектирования.

В задании нужно реализовать сообщение о логировании с типом сообщения и самим сообщением:
```
class LogMessage {
public:
    Type type() const;
    const std::string& message() const;
};
```

Всего должно быть четыре типа сообщений:

- предупреждение,
- ошибка,
- фатальная ошибка,
- неизвестное сообщение.

Далее нужно добавить обработчиков для разных типов, которые будут обрабатывать сообщения
по приоритету:

- фатальная ошибка,
- ошибка,
- предупреждение,
- неизвестное сообщение.

Каждый обработчик умеет:

- обрабатывать сообщение только определённого типа,
- передавать сообщение следующему обработчику.

Вот что обработчик должен уметь в зависимости от типа сообщения.

- Обработчик фатальной ошибки должен выбросить исключение с текстом сообщения, потому что предполагается, что программа должна прекратить выполнение после возникновения фатальной ошибки.
- Обработчик обычной ошибки должен записать её в файл по указанному пути.
- Обработчик предупреждения должен напечатать сообщение в консоль.
- Обработчик неизвестного сообщения должен выбросить исключение с текстом о необработанном
сообщении.

